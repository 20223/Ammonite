<html><head><link href="META-INF/resources/webjars/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" /><link href="styles.css" rel="stylesheet" /><style>
.scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.05;
  text-decoration: none;
}


.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.5;
  text-decoration: none;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:hover{
  opacity: 1.0;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:active{
  opacity: 0.75;
}

.scalatex-site-Styles-content{
  color: #777;
  line-height: 1.6em;
  margin: 0 auto;
  margin-left: auto;
  margin-right: auto;
  max-width: 800;
  padding: 0 1em;
  padding-bottom: 50px;
}
.scalatex-site-Styles-content *{
  position: relative;
}
.scalatex-site-Styles-content p{
  text-align: justify;
}
.scalatex-site-Styles-content a:link{
  color: #37a;
  text-decoration: none;
}
.scalatex-site-Styles-content a:visited{
  color: #949;
  text-decoration: none;
}
.scalatex-site-Styles-content a:hover{
  text-decoration: underline;
}
.scalatex-site-Styles-content a:active{
  color: #000;
  text-decoration: underline;
}
.scalatex-site-Styles-content code{
  color: #000;
}

/*Workaround for bug in highlight.js IDEA theme*/
span.hljs-tag, span.hljs-symbol{
    background: none;
}
    </style><script src="scripts.js"></script></head><body><div>
<a href="https://github.com/lihaoyi/ammonite" style="position: absolute;top: 0px;right: 0px;border: 0;"><img src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" /></a>
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Ammonite" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Ammonite<a class=" scalatex-site-Styles-headerLink" href="#Ammonite" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div><div class=" scalatex-site-Styles-content">
  <p>
    <a href="https://github.com/lihaoyi/Ammonite">Ammonite</a> is a collection of Scala libraries intended to improve the experience of using Scala as an system shell. It includes two independent modules:
</p>
  <ul>
    <li>
      <a href="#Ammonite-Ops">Ammonite-Ops</a>: A library for performing filesystem operations (reading, writing, copying, deleting, etc.) concisely in Scala. Much easier than doing things manually using <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">java.io</code>, while statically-typed and much safer than shelling out to Bash scripts.
</li>
    <li>
      <a href="#Ammonite-REPL">Ammonite-REPL</a>: A modern, drop-in replacement for the standard Scala REPL (usable in any SBT project) with many <a href="#Features">new features</a> and better usability to make your shell usage a pleasant experience.
</li></ul>
  <p>
    Each of these are independent modules that are each usable on their own. Together, they form the basis of a systems shell that can be used as a replacement for the <a href="http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29">Bash shell</a> for performing common system housekeeping tasks. Separately, <a href="#Ammonite-Ops">Ammonite-Ops</a> is a best-in-class file-system IO library and <a href="#Ammonite-REPL">Ammonite-REPL</a> is a best-in-class Scala REPL.
</p>
  <p>
    Ammonite for now only works on Unix/OS-X/Linux (i.e. no <a href="https://github.com/lihaoyi/Ammonite/issues/18">Windows support</a>) and Java 7 and above.


    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Ammonite-Ops" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;" id="Ammonite-Ops">Ammonite-Ops<a class=" scalatex-site-Styles-headerLink" href="#Ammonite-Ops" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /><h2 style="font-weight: 300;color: #ccc;padding: 0px;margin-top: 0px;">Rock-solid Filesystem Operations</h2></div>
      
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import ammonite.ops._

// Pick the directory you want to work with,
// relative to the process working dir
val wd = cwd/'ops/'target/&quot;scala-2.11&quot;/&quot;test-classes&quot;/'example2

// Delete a file or folder, if it exists
rm! wd

// Make a folder named &quot;folder&quot;
mkdir! wd/'folder

// Copy a file or folder
cp(wd/'folder, wd/'folder1)

// List the current directory
val listed = ls! wd

// Write to a file without pain! Necessary
// enclosing directories are created automatically
write(wd/'dir2/&quot;file1.scala&quot;, &quot;package example\nclass Foo{}&quot;)
write(wd/'dir2/&quot;file2.scala&quot;, &quot;package example\nclass Bar{}&quot;)

// Rename all .scala files inside the folder d into .java files
ls! wd/'dir2 | mv{case r&quot;$x.scala&quot; =&gt; s&quot;$x.java&quot;}

// List files in a folder
val renamed = ls! wd/'dir2

// Line-count of all .java files recursively in wd
val lineCount = ls.rec! wd |? (_.ext == &quot;java&quot;) | read.lines | (_.size) sum

// Find and concatenate all .java files directly in the working directory
ls! wd/'dir2|? (_.ext == &quot;java&quot;) | read |&gt; write! wd/'target/&quot;bundled.java&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/ops/src/test/scala/test/ammonite/ops/ExampleTests.scala#L9-L44" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>
        Ammonite-Ops is a collection of tools intended to make common filesystem operations in Scala as concise and easy-to-use as from the Bash shell, while being robust enough to use in large applications without getting messy.
</p>
      <p>
        As you can see, Ammonite-Ops replaces the common mess of boilerplate:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def removeAll(path: String) = {
  def getRecursively(f: java.io.File): Seq[java.io.File] = {
    f.listFiles.filter(_.isDirectory).flatMap(getRecursively) ++ f.listFiles
  }
  getRecursively(new java.io.File(path)).foreach{f =&gt;
    println(f)
    if (!f.delete())
      throw new RuntimeException(&quot;Failed to delete &quot; + f.getAbsolutePath)
  }
  new java.io.File(path).delete
}
removeAll(&quot;target/folder/thing&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/ops/src/test/scala/test/ammonite/ops/ExampleTests.scala#L80-L93" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>
        With a single, sleek expression:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">rm! cwd/'target/'folder/'thing</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/ops/src/test/scala/test/ammonite/ops/ExampleTests.scala#L97-L98" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>
        That handles the common case for you: recursively deleting folders, not-failing if the file doesn't exist, etc.
</p>
      <p>
        To get started, add this to your <code>build.sbt</code>:
</p>
      <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;com.lihaoyi&quot; %% &quot;ammonite-ops&quot; % &quot;0.3.0&quot;</code>

      <p>
        And this at the top of the file you want to use Ammonite:
</p>
      <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import ammonite.ops._</code>

      <p>
        And you're all set!
</p>
      <h1 id="Paths" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Paths" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Paths</h1>
        <p>
          Ammonite uses strongly-typed data-structures to represent filesystem paths. The two basic versions are:
</p>
        <ul>
          <li>
            <code>Path</code>: an absolute path, starting from the root
</li>
          <li>
            <code>RelPath</code>: a relative path, not rooted anywhere
</li></ul>
        <p>
          Generally, almost all commands take absolute <code>Path</code>s. These are basically defined as:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">case class Path(segments: Seq[String]) extends BasePathImpl[Path]{</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/ops/src/main/scala/ammonite/ops/Path.scala#L224-L225" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
          With a number of useful operations that can be performed on them. Absolute paths can be created in a few ways:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">// Get the process' Current Working Directory. As a convention
// the directory that &quot;this&quot; code cares about (which may differ
// from the cwd) is called `wd`
val wd = cwd

// A path nested inside `wd`
wd/'folder/'file

// A path starting from the root
root/'folder/'file

// A path with spaces or other special characters
wd/&quot;My Folder&quot;/&quot;My File.txt&quot;

// Up one level from the wd
wd/up

// Up two levels from the wd
wd/up/up</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/ops/src/test/scala/test/ammonite/ops/ExampleTests.scala#L102-L121" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
          Note that there are no in-built operations to change the `cwd`. In general you should not need to: simply defining a new path, e.g.
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val target = cwd/'target</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/ops/src/test/scala/test/ammonite/ops/ExampleTests.scala#L123-L124" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
          Should be sufficient for most needs.
</p>
        <p>
          Above, we made use of the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">cwd</code> built-in path. There are a number of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Path</code>s built into Ammonite:
</p>
        <ul>
          <li>
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">cwd</code>: The current working directory of the process. This can't be changed in Java, so if you need another path to work with the convention is to define a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">wd</code> variable.</li>
          <li>
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">root</code>: The root of the filesystem.</li>
          <li>
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">home</code>: The home directory of the current user.</li>
          <li>
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">makeTmp</code>: Creates a temporary folder and returns the path.
</li></ul>
      <h1 id="RelPaths" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#RelPaths" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>RelPaths</h1>
        <p>
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">RelPath</code>s represent relative paths. These are basically defined as:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">case class RelPath(segments: Seq[String], ups: Int) extends BasePathImpl[RelPath]{</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/ops/src/main/scala/ammonite/ops/Path.scala#L131-L132" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
          The same data structure as <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Path</code>s, except that they can represent a number of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">up</code>s before the relative path is applied. They can be created in the following ways:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">// The path &quot;folder/file&quot;
val rel1 = 'folder/'file
val rel2 = 'folder/'file

// The path &quot;file&quot;; will get converted to a RelPath by an implicit
val rel3 = 'file

// The relative difference between two paths
val target = cwd/'target/'file
assert(target - cwd == 'target/'file)

// `up`s get resolved automatically
val minus = cwd - target
val ups = up/up
assert(minus == ups)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/ops/src/test/scala/test/ammonite/ops/ExampleTests.scala#L126-L141" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
          In general, very few APIs take relative paths. Their main purpose is to be combined with absolute paths in order to create new absolute paths. e.g.
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val target = cwd/'target/'file
val rel = target - cwd
val newBase = root/'code/'server
assert(newBase/rel == root/'code/'server/'target/'file)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/ops/src/test/scala/test/ammonite/ops/ExampleTests.scala#L146-L150" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
          <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">up</code> is a relative path that comes in-built:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val target = root/'target/'file
assert(target/up == root/'target)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/ops/src/test/scala/test/ammonite/ops/ExampleTests.scala#L152-L154" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
          Note that all paths, both relative and absolute, are always expressed in a canonical manner:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">assert((root/'folder/'file/up).toString == &quot;/folder&quot;)
// not &quot;/folder/file/..&quot;

assert(('folder/'file/up).toString == &quot;folder&quot;)
// not &quot;folder/file/..&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/ops/src/test/scala/test/ammonite/ops/ExampleTests.scala#L156-L161" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
          So you don't need to worry about canonicalizing your paths before comparing them for equality or otherwise manipulating them.
</p>
      <h1 id="PathOperations" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#PathOperations" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Path Operations</h1>

        <p>
          Ammonite's paths are transparent data-structures, and you can always access the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">segments</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ups</code> directly. Nevertheless, Ammonite defines a number of useful operations that handle the common cases of dealing with these paths:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">trait BasePath[ThisType &lt;: BasePath[ThisType]]{
  /**
   * The individual path segments of this path.
   */
  def segments: Seq[String]

  /**
   * Combines this path with the given relative path, returning
   * a path of the same type as this one (e.g. `Path` returns `Path`,
   * `RelPath` returns `RelPath`
   */
  def /(subpath: RelPath): ThisType

  /**
   * Relativizes this path with the given `base` path, finding a
   * relative path `p` such that base/p == this.
   *
   * Note that you can only relativize paths of the same type, e.g.
   * `Path` &amp; `Path` or `RelPath` &amp; `RelPath`. In the case of `RelPath`,
   * this can throw a [[PathError.NoRelativePath]] if there is no
   * relative path that satisfies the above requirement in the general
   * case.
   */
  def -(target: ThisType): RelPath

  /**
   * This path starts with the target path, including if it's identical
   */
  def &gt;=(target: ThisType): Boolean
  /**
   * This path starts with the target path and is strictly longer than it
   */
  def &gt;(target: ThisType): Boolean
  /**
   * The target path starts with this path, including if it's identical
   */
  def &lt;=(target: ThisType): Boolean
  /**
   * The target path starts with this path and is strictly longer than it
   */
  def &lt;(target: ThisType): Boolean

  /**
   * The last segment in this path. Very commonly used, e.g. it
   * represents the name of the file/folder in filesystem paths
   */
  def last: String
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/ops/src/main/scala/ammonite/ops/Path.scala#L38-L87" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
          In this definition, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ThisType</code> represents the same type as the current path; e.g. a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Path</code>'s <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">/</code> returns a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Path</code> while a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">RelPath</code>'s <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">/</code> returns a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">RelPath</code>. Similarly, you can only compare or subtract paths of the same type.
</p>
        <p>
          Apart from <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">RelPath</code>s themselves, a number of other data structures are convertible into <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">RelPath</code>s when spliced into a path using <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">/</code>:
</p>
        <ul>
          <li>
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">String</code>s</li>
          <li>
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Symbols</code>s</li>
          <li>
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Array[T]</code>s where <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T</code> is convertible into a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">RelPath</code></li>
          <li>
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Seq[T]</code>s where <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T</code> is convertible into a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">RelPath</code>
</li></ul>
      <h1 id="Extensions" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Extensions" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Extensions</h1>
        <p>
          Ammonite-Ops contains a set of extension methods on common types, which serve no purpose other than to make things more concise. These turn Scala from a &quot;relatively-concise&quot; language into one as tight as Bash scripts, while still maintaining the high level of type-safety and maintainability that comes with Scala code.
</p>
        <h2 id="Traversable" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Traversable" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Traversable</h2>
          <p>
            These extensions apply to any <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Traversable</code>: <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Seq</code>s, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">List</code>s, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Array</code>s, and others.</p>
          <ul>
            <li>
              <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">things | f</code> is an alias for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">things map f</code></li>
            <li>
              <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">things || f</code> is an alias for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">things flatMap f</code></li>
            <li>
              <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">things |? f</code> is an alias for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">things filter f</code></li>
            <li>
              <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">things |&amp; f</code> is an alias for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">things reduce f</code></li></ul>
          <p>
            These should behave exactly the same as their implementations; their sole purpose is to make things more concise at the command-line.
</p>
        <h2 id="Pipeable" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Pipeable" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Pipeable</h2>
          <ul>
            <li>
              <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">thing |&gt; f</code> is an alias for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">f(thing)</code>
</li></ul>
          <p>
            This lets you flip around the function and argument, and fits nicely into the Ammonite's <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">|</code> pipelines.
</p>
      <h1 id="Operations" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Operations" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Operations</h1>
        <p>
          All these <a href="#Paths">Paths</a> and <a href="#Extensions">Extensions</a> and what-not aren't interesting on their own, but serve as a base to use to perform filesystem operations in a concise and easy to use way. Here is a smattering of those operations:
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">/**
 * An [[Op1]] that returns a Seq[R], but can also do so
 * lazily (Iterator[R]) via `op.!! arg`. You can then use
 * the iterator however you wish
 */
trait StreamableOp1[T1, R, C &lt;: Seq[R]] extends Op1[T1, C]
/**
 * Makes directories up to the specified path. Equivalent
 * to `mkdir -p` in bash
 */
object mkdir extends Op1[Path, Unit]
/**
 * Moves a file from one place to another.
 * Creates any necessary directories
 */
object mv extends Op2[Path, Path, Unit] with Internals.Mover
/**
 * Copies a file or folder from one place to another.
 * Creates any necessary directories, and copies folders
 * recursively.
 */
object cp extends Op2[Path, Path, Unit] 
/**
 * Roughly equivalent to bash's `rm -rf`. Deletes
 * any files or folders in the target path, or
 * does nothing if there aren't any
 */
object rm extends Op1[Path, Unit]
/**
 * List the files and folders in a directory
 */
object ls extends StreamableOp1[Path, Path, LsSeq]
  /**
   * Reads a classpath resource into memory, either as a
   * string, as a Seq[String] of lines, or as a Array[Byte]
   */
  object rec extends StreamableOp1[Path, Path, LsSeq]
/**
 * Write some data to a file. This can be a String, an Array[Byte], or a
 * Seq[String] which is treated as consecutive lines. By default, this
 * fails if a file already exists at the target location. Use [[write.over]]
 * or [[write.append]] if you want to over-write it or add to what's already
 * there.
 */
object write extends Op2[Path, Internals.Writable, Unit]
  /**
   * Identical to [[write]], except if the file already exists,
   * appends to the file instead of error-ing out
   */
  object append extends Op2[Path, Internals.Writable, Unit]
  /**
   * Identical to [[write]], except if the file already exists,
   * replaces the file instead of error-ing out
   */
  object over extends Op2[Path, Internals.Writable, Unit]
/**
 * Reads a file into memory, either as a String,
 * as (read.lines(...): Seq[String]), or as (read.bytes(...): Array[Byte]).
 */
object read extends Internals.Reader with Op1[Path, String]
  /**
   * Reads a classpath resource into memory, either as a
   * string, as a Seq[String] of lines, or as a Array[Byte]
   */
  object resource extends Internals.Reader with Op1[Path, String]
/**
 * Checks if a file or folder exists at the given path.
 */
object exists extends Op1[Path, Boolean]
/**
 * Kills the given process with the given signal, e.g.
 * `kill(9)! pid`
 */
case class kill(signal: Int) extends Op1[Int, CommandResult]</code></pre>

        <p>
          In these definitions, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Op1</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Op2</code> are isomorphic to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Function1</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Function2</code>. The main difference is that ops can be called in two ways:
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">rm(filepath)
rm! filepath
</code></pre>
        <p>
          The latter syntax allows you to use it more easily from the command line, where remembering to close all your parenthesis is a hassle. Indentation signifies nesting, e.g. in addition to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">write!</code> you also have <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">write.append!</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">write.over!</code>
</p>
        <p>
          All of these operations are pre-defined and strongly typed, so feel free to jump to their implementation to look at what they do or what else is available.
</p>
        <p>
          In general, each operator has sensible/safe defaults:
</p>
        <ul>
          <li>
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">rm</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">cp</code> are recursive</li>
          <li>
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">rm</code> ignores the file if it doesn't exist</li>
          <li>
            all operations that create a file or folder (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">mkdir</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">write</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">mv</code>) automatically create any necessary parent directories</li>
          <li>
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">write</code> also does <i>not</i> stomp over existing files by default. You need to use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">write.over</code></li></ul>
        <p>
          In general, this should make these operations much easier to use; the defaults should cover the 99% use case without needing any special flags or fiddling.
</p>
      <h1 id="Chaining" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Chaining" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Chaining</h1>
        <p>
          The real value of Ammonite is the fact that you can pipe things together as easily as you could in Bash. No longer do you need to write reams of boilerplate. to accomplish simple tasks. Some of these chains are listed at the top of this readme, here are a few more fun examples:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">// Move all files inside the &quot;py&quot; folder out of it
ls! wd/&quot;py&quot; | mv.all*{case d/&quot;py&quot;/x =&gt; d/x }

// Find all dot-files in the current folder
val dots = ls! wd |? (_.last(0) == '.')

// Find the names of the 10 largest files in the current working directory
ls.rec! wd | (x =&gt; x.size -&gt; x) sortBy (-_._1) take 10

// Sorted list of the most common words in your .scala source files
def txt = ls.rec! wd |? (_.ext == &quot;scala&quot;) | read
def freq(s: Seq[String]) = s groupBy (x =&gt; x) mapValues (_.length) toSeq
val map = txt || (_.split(&quot;[^a-zA-Z0-9_]&quot;)) |&gt; freq sortBy (-_._2)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/ops/src/test/scala/test/ammonite/ops/ExampleTests.scala#L56-L70" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
          As you can see, you can often compose elaborate operations entirely naturally using the available pipes, without needing to remember any special flags or techniques.
</p>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Ammonite-REPL" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;" id="Ammonite-REPL">Ammonite-REPL<a class=" scalatex-site-Styles-headerLink" href="#Ammonite-REPL" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /><h2 style="font-weight: 300;color: #ccc;padding: 0px;margin-top: 0px;">A Modernized Scala REPL</h2></div>
      
      <p>
        Ammonite-REPL is a cleanroom re-implementation of the Scala REPL from first principles. It is much more featureful than the default REPL and comes with a lot of ergonomic improvements that may be familiar to people coming from IDEs or other REPLs such as <a href="ipython.org">IPython</a> or <a href="http://www.zsh.org/">Zsh</a>.</p>
      <p>
        To try out Ammonite-REPL in an existing project, add the following to your <code>build.sbt</code>
</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">libraryDependencies += &quot;com.lihaoyi&quot; % &quot;ammonite-repl&quot; % &quot;0.3.0&quot; % &quot;test&quot; cross CrossVersion.full

initialCommands in (Test, console) := &quot;&quot;&quot;ammonite.repl.Repl.run(&quot;&quot;)&quot;&quot;&quot;
</code></pre>
      <p>
        After that, simple hit</p>
      <code>
        sbt projectName/test:console</code>
      <p>
        To activate the Ammonite REPL</p>
      <p>
        If you want the AmmoniteREPL to be available in all projects, simply add the above snippet to a new file <code>~/.sbt/0.13/global.sbt</code>.
</p>
      <h1 id="Features" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Features" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Features</h1>
        <p>
          Ammonite-REPL supports many more features than the default REPL, including:
</p>
        <h2 id="ArtifactLoading" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ArtifactLoading" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Artifact Loading</h2>

          <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">@ import scalatags.Text.all._
error: not found: value scalatags

@ load.ivy(&quot;com.lihaoyi&quot; %% &quot;scalatags&quot; % &quot;0.4.5&quot;)

@ import scalatags.Text.all._
import scalatags.Text.all._

@ a(&quot;omg&quot;, href:=&quot;www.google.com&quot;).render
res2: String = $tq
&lt;a href=&quot;www.google.com&quot;&gt;omg&lt;/a&gt;
$tq</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/repl/src/test/scala/ammonite/repl/AdvancedTests.scala#L14-L26" target="_blank"><i class="fa fa-link "></i></a></pre>

          <p>
            Ammonite allows you to load artifacts directly from maven central by copy &amp; pasting their SBT ivy-coordinate-snippet. In addition, you can also load in jars as <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">java.io.File</code>s to be included in the session or simple <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">String</code>s to be executed using the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">load</code> command.
</p>
          <p>
            This makes Ammonite ideal for trying out new libraries or tools. You can pull down projects like <a href="https://github.com/scalaz/scalaz">Scalaz</a> or <a href="https://github.com/milessabin/shapeless">Shapeless</a> and immediately start working with them in the REPL:
</p>
          <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">@ load.ivy(&quot;org.scalaz&quot; %% &quot;scalaz-core&quot; % &quot;7.1.1&quot;)

@ import scalaz._
import scalaz._

@ import Scalaz._
import Scalaz._

@ (Option(1) |@| Option(2))(_ + _)
res3: scala.Option[Int] = Some(3)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/repl/src/test/scala/ammonite/repl/AdvancedTests.scala#L196-L206" target="_blank"><i class="fa fa-link "></i></a></pre>

          <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">@ load.ivy(&quot;com.chuusai&quot; %% &quot;shapeless&quot; % &quot;2.1.0&quot;)

@ import shapeless._

@ (1 :: &quot;lol&quot; :: List(1, 2, 3) :: HNil)(1)
res2: java.lang.String = &quot;lol&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/repl/src/test/scala/ammonite/repl/AdvancedTests.scala#L185-L191" target="_blank"><i class="fa fa-link "></i></a></pre>

        <h2 id="Pretty-printedoutput" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Pretty-printedoutput" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Pretty-printed output</h2>

          <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">@ Seq.fill(10)(Seq.fill(3)(&quot;Foo&quot;))
res0: Seq[Seq[java.lang.String]] = List(
  List(&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;),
  List(&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;),
  List(&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;),
  List(&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;),
  List(&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;),
  List(&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;),
  List(&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;),
  List(&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;),
  List(&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;),
  List(&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;)
)

@ case class Foo(i: Int, s0: String, s1: Seq[String])
defined class Foo

@ Foo(1, &quot;&quot;, Nil)
res2: cmd1.Foo = Foo(1, &quot;&quot;, List())

@ Foo(1234567, &quot;I am a cow, hear me moo&quot;, Seq(&quot;I weigh twice as much as you&quot;, &quot;and I look good on the barbecue&quot;))
res3: cmd1.Foo = Foo(
  1234567,
  &quot;I am a cow, hear me moo&quot;,
  List(&quot;I weigh twice as much as you&quot;, &quot;and I look good on the barbecue&quot;)
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/repl/src/test/scala/ammonite/repl/AdvancedTests.scala#L115-L141" target="_blank"><i class="fa fa-link "></i></a></pre>

          <p>
            Ammonite-REPL uses <a href="#Ammonite-PPrint">Ammonite-PPrint</a> to display its output by default. That means that everything is nicely formatted to fit within the width of the terminal, and is copy-paste-able!</p>
        <h2 id="ConfigurableTruncation" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ConfigurableTruncation" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Configurable Truncation</h2>
          <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">@ Seq.fill(20)(100)
res0: Seq[Int] = List(
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
...

@ show(Seq.fill(20)(100))
res1: ammonite.pprint.Show[Seq[Int]] = List(
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100,
  100
)

@ show(Seq.fill(20)(100), lines = 3)
res2: ammonite.pprint.Show[Seq[Int]] = List(
  100,
  100,
...

@ pprintConfig = pprintConfig.copy(lines = 5)

@ Seq.fill(20)(100)
res4: Seq[Int] = List(
  100,
  100,
  100,
  100,
...</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/repl/src/test/scala/ammonite/repl/AdvancedTests.scala#L252-L309" target="_blank"><i class="fa fa-link "></i></a></pre>

          <p>
            Ammonite-REPL intelligently truncates your output when it's beyond a certain size. You can request for the full output to be printed on-demand, print a certain number of lines, or even change the implicit <code>pprintConfig</code> so subsequent lines all use your new configuration.

</p>
        <h2 id="SuperiorAutocomplete" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#SuperiorAutocomplete" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Superior Autocomplete</h2>
          <p>
            The original Scala REPL provides no autocomplete except for the most basic scenarios of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">value.&lt;complete&gt;</code>. In the Ammonite-REPL, you get the same autocomplete-anywhere support that you get in a modern IDE.
</p>
          <pre><code class="scala scalatex-site-Styles-highlightMe">  @ Seq(1, 2, 3).map(x =&gt; x.)
  getClass            ##                  asInstanceOf        isInstanceOf
  toString            hashCode            equals              !=
  ==                  %                   /                   *
  -                   +                   ^                   &amp;
  |                   &gt;=                  &gt;                   &lt;=
  &lt;                   &gt;&gt;                  &gt;&gt;&gt;                 &lt;&lt;
  unary_-             unary_+             unary_~             toDouble
  toFloat             toLong              toInt               toChar
  toShort             toByte              compareTo           doubleValue
  ...

  @ Futu
  scala.collection.parallel.FutureThreadPoolTasks
  scala.collection.parallel.FutureTasks
  scala.concurrent.impl.Future$PromiseCompletingRunnable
  scala.concurrent.impl.Future
  scala.concurrent.Future
  scala.concurrent.FutureTaskRunner
  scala.concurrent.Future$InternalCallbackExecutor
  scala.concurrent.Future$class
  java.util.concurrent.Future
  java.util.concurrent.FutureTask$WaitNode
  java.util.concurrent.FutureTask
  com.sun.corba.se.impl.orbutil.closure.Future
</code></pre>

          <p>
            Neither of these examples work in the standard Scala REPL.
</p>
        <h2 id="Interruptingrun-awayexecutionwithCtrl-C" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Interruptingrun-awayexecutionwithCtrl-C" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Interrupting run-away execution with Ctrl-C</h2>
          <pre><code class="scala scalatex-site-Styles-highlightMe">  @ while(true) ()
  ... hangs ...
  ^Ctrl-C
  Interrupted!

  @
</code></pre>
          <p>
            The traditional Scala REPL doesn't handle runaway code, and gives you no option but to kill the process, losing all your work. Ammonite-REPL lets you interrupt the thread, stop the runaway-command and keep going.
</p>
        <h2 id="Compiler-crashRobustness" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Compiler-crashRobustness" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Compiler-crash Robustness</h2>
          <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">@ val x = 1
x: Int = 1

@ /* trigger compiler crash */ trait Bar { super[Object].hashCode }
error: java.lang.AssertionError: assertion failed

@ 1 + x
res1: Int = 2</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/repl/src/test/scala/ammonite/repl/FailureTests.scala#L25-L33" target="_blank"><i class="fa fa-link "></i></a></pre>

          <p>
            The default Scala REPL throws away all your work if the compiler crashes. This doesn't make any sense, because all the compiler is is a dumb <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">String =&gt; Array[Byte]</code> pipe. In the Ammonite, we simply swap out the broken compiler for a new one and let you continue your work.</p>
        <h2 id="OtherFixes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#OtherFixes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Other Fixes</h2>
          <p>
            Apart from the above features, the Ammonite REPL fixes a large number of bugs in the default Scala REPL, including but not limited to:</p>
          <ul>
            
            
              <li><a href="https://issues.scala-lang.org/browse/SI-6302">SI-6302</a></li>
            
              <li><a href="https://issues.scala-lang.org/browse/SI-8971">SI-8971</a></li>
            
              <li><a href="https://issues.scala-lang.org/browse/SI-9249">SI-9249</a></li>
            
              <li><a href="https://issues.scala-lang.org/browse/SI-4438">SI-4438</a></li>
            
              <li><a href="https://issues.scala-lang.org/browse/SI-8603">SI-8603</a></li>
            
              <li><a href="https://issues.scala-lang.org/browse/SI-6660">SI-6660</a></li>
            
              <li><a href="https://issues.scala-lang.org/browse/SI-7953">SI-7953</a></li>
            
              <li><a href="https://issues.scala-lang.org/browse/SI-6659">SI-6659</a></li>
            
              <li><a href="https://issues.scala-lang.org/browse/SI-8456">SI-8456</a></li>
            
              <li><a href="https://issues.scala-lang.org/browse/SI-1067">SI-1067</a></li>
            
              <li><a href="https://issues.scala-lang.org/browse/SI-8307">SI-8307</a></li>
            </ul>
      <h1 id="Builtins" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Builtins" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Builtins</h1>
        <p>
          Ammonite contains a range of useful built-ins implemented as normal functions. Everything inside the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ReplAPI</code> trait is imported by default and can be accessed directly by default to control the console.
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">trait ReplAPI {
  /**
   * Exit the Ammonite REPL. You can also use Ctrl-D to exit
   */
  def exit = throw ReplExit

  /**
   * Clears the screen of the REPL
   */
  def clear: Unit

  /**
   * Read/writable prompt for the shell. Use this to change the
   * REPL prompt at any time!
   */
  var shellPrompt: String

  /**
   * Display this help text
   */
  def help: String

  /**
   * History of commands that have been entered into the shell
   */
  def history: Seq[String]

  /**
   * Get the `Type` object of [[T]]. Useful for finding
   * what its methods are and what you can do with it
   */
  def typeOf[T: WeakTypeTag]: Type

  /**
   * Get the `Type` object representing the type of `t`. Useful
   * for finding what its methods are and what you can do with it
   *
   */
  def typeOf[T: WeakTypeTag](t: =&gt; T): Type
  
  /**
   * Tools related to loading external scripts and code into the REPL
   */
  def load: Load

  /**
   * Throw away the current scala.tools.nsc.Global and get a new one
   */
  def newCompiler(): Unit

  /**
   * Prettyprint the given `value` with no truncation. Optionally takes
   * a number of lines to print.
   */
  def show[T](value: T, lines: Int = 0): ammonite.pprint.Show[T]
  /**
   * Show all the imports that are used to execute commands going forward
   */
  def imports: String
  /**
   * Controls how things are pretty-printed in the REPL. Feel free
   * to shadow this with your own definition to change how things look
   */
  implicit var pprintConfig: ammonite.pprint.Config
}
trait Load extends (String =&gt; Unit){
  /**
   * Load a `.jar` file
   */
  def jar(jar: java.io.File): Unit
  /**
   * Load a library from its maven/ivy coordinates
   */
  def ivy(coordinates: (String, String, String), verbose: Boolean = true): Unit

  /**
   * Loads a command into the REPL and
   * evaluates them one after another
   */
  def apply(line: String): Unit
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/ammonite/tree/master/repl/src/main/scala/ammonite/repl/frontend/ReplAPI.scala#L20-L102" target="_blank"><i class="fa fa-link "></i></a></pre>

    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Ammonite-PPrint" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;" id="Ammonite-PPrint">Ammonite-PPrint<a class=" scalatex-site-Styles-headerLink" href="#Ammonite-PPrint" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
      <p>
        Ammonite comes with a pretty-printing module, which lets you easily print data structures in a readable way. This is most often used in Ammonite-Repl, but can also be used standalone if desired:
</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; import ammonite.pprint._
scala&gt; import Config.Defaults._

scala&gt; PPrint(
  List(Seq(Seq(&quot;mgg&quot;, &quot;mgg&quot;, &quot;lols&quot;), Seq(&quot;mgg&quot;, &quot;mgg&quot;)), Seq(Seq(&quot;ggx&quot;, &quot;ggx&quot;),Seq(&quot;ggx&quot;, &quot;ggx&quot;, &quot;wtfx&quot;)))
)
res33: String =
List(
  List(List(&quot;mgg&quot;, &quot;mgg&quot;, &quot;lols&quot;), List(&quot;mgg&quot;, &quot;mgg&quot;)),
  List(List(&quot;ggx&quot;, &quot;ggx&quot;), List(&quot;ggx&quot;, &quot;ggx&quot;, &quot;wtfx&quot;))
)
</code></pre>
      <p>
        Note how every string is escaped, everything is laid out nicely, and the output is in a state that you can easily copy &amp; paste it back into the REPL to evaluate.</p>
      <p>
        You can also use</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">import Configs.Colors._</code></pre>
      <p>
        Instead of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Defaults</code> in order to turn on colored pretty-printing.</p>
      <p>
        Pretty-printing is by default defined for most standard library types, as well as case classes and case objects. For other types not supported, it falls back to using <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">toString</code>
</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">  scala&gt; PPrint(new Object())
  res35: String = java.lang.Object@54f880c0
</code></pre>
      <p>
        In order to pretty print a type <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T</code>, you need to have a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T: PPrint</code> context bound present. In order to write your own custom pretty printer for some type <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T</code>, provide a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">PPrinter[T]</code>.</p></p>
  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Changelog" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;" id="Changelog">Changelog<a class=" scalatex-site-Styles-headerLink" href="#Changelog" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <h1 id="0.3.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.0</h1>
      <ul>
        <li>
          allow <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">predef</code> parameter to be passed into <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Repl.run()</code> call, letting you configure initialization commands or imports</li>
        <li>
          Compilation errors in expressions no longer show synthetic code in the message</li>
        <li>
          Ivy module loading now lets you configure verbosity level</li>
        <li>
          Defining macros in the REPL and using them in subsequent lines now works</li>
        <li>
          Output lines are now truncated past a certain length, which is configurable
</li></ul>
    <h1 id="0.2.9" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.2.9" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.2.9</h1>
      <ul>
        <li>
          Lots of improvements to <code>Ctrl-C</code> and <code>Ctrl-D</code> handling, to make it behave more like other REPLs
</li></ul>
    <h1 id="0.2.8" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.2.8" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.2.8</h1>
      <ul>
        <li>
          Fix #47: PPrint derivation fails with nested case class</li>
        <li>
          Fix #14: Exception when trying to use Ammonite REPL #15 by cross building against Scala 2.10.{3,4,5} and 2.11.{3,4,5,6}</li>
        <li>
          Autocomplete results are sorted alphabetically (Fixed #42)</li>
        <li>
          Fix #39: nothing echoed on multiple import</li>
        <li>
          Importing things from Java packages now works properly</li></ul></div></div><script>
    scalatex.scrollspy.Controller().main(
      [{"value":"Ammonite","children":[{"value":"Ammonite-Ops","children":[{"value":"Paths","children":[]},{"value":"RelPaths","children":[]},{"value":"Path Operations","children":[]},{"value":"Extensions","children":[{"value":"Traversable","children":[]},{"value":"Pipeable","children":[]}]},{"value":"Operations","children":[]},{"value":"Chaining","children":[]}]},{"value":"Ammonite-REPL","children":[{"value":"Features","children":[{"value":"Artifact Loading","children":[]},{"value":"Pretty-printed output","children":[]},{"value":"Configurable Truncation","children":[]},{"value":"Superior Autocomplete","children":[]},{"value":"Interrupting run-away execution with Ctrl-C","children":[]},{"value":"Compiler-crash Robustness","children":[]},{"value":"Other Fixes","children":[]}]},{"value":"Builtins","children":[]}]},{"value":"Ammonite-PPrint","children":[]},{"value":"Changelog","children":[{"value":"0.3.0","children":[]},{"value":"0.2.9","children":[]},{"value":"0.2.8","children":[]}]}]}]
  )</script><script>
    ['DOMContentLoaded', 'load'].forEach(function(ev){
      addEventListener(ev, function(){
        Array.prototype.forEach.call(
          document.getElementsByClassName('scalatex-site-Styles-highlightMe'),
          hljs.highlightBlock
        );
      })
    })
  </script></body></html>